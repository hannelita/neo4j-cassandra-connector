= Neo4j Cassandra Connector
:toc:
:toclevels: 6
:sectnums:

toc::[]

== Our Goal

=== What is Neo4j Cassandra Connector?

It is a tool that enables you to migrate information that is inside Cassandra to a Neo4j property graph structure. 

=== A little longer explanation

It's way challenging to map a database like Cassandra to a graph world. But we tried our best here.

==== About this first version

The main goal here is to provide a direct way to map a Cassandra schema to Neo4j and import result sets that come from Cassandra columns to Neo4j graph model, generating a meaningful representation of nodes and relationships. This translation is made by inserting CQL queries via Python Cassandra Driver into a  file, filling up a YAML file representing the schema of a keyspace and then running the queries. The final output should be a graph into Neo4j with a file containing the corresponding Cypher queries. The following sections will guide through this process and also provide some mapping examples.

===== Populating an initial Cassandra Database

To use this initial version, you must:

* Download and install link:http://cassandra.apache.org/download/ [Cassandra].
* Start Cassandra by running ```./bin/cassandra```
* Download and install link: http://neo4j.com/download/other-releases/ [Neo4j]. We recommend versions 2.3.1 and above.
* Start Neo4j.
* Populate a Sample DB in Cassandra. Simply go to ::db_gen:: folder, start Cassandra ::cqlsh:: and invoke the command ::SOURCE '/playlist.cql'::. You can also provide the absolute path of the file. This will populate your Cassandra database with some Tracks and Artists database.

==== Generating a schema.yaml file

After populating your initial database, you must generate a file to properly map a Cassandra Schema to a graph. Do the following:

* Into the project directory, navigate to the subfolder __connector/__
* Run the script ::connector.py::. Invoke it with ::python connector.py::. Note that Python ```cassandra-driver``` is required.
* Some output files will be generated. At this stage, take a look into the generated ::schema.yaml:: file. It contains a YAML representation of Cassandra Schema. 

The next step consists into filling up this file with mapping information. Check out the next section for more information.

==== Filling up schema.yaml file

__schema.yaml__ file might have the following look and feel:

```
CREATE TABLE playlist.artists_by_first_letter:
    first_letter text: {}
    artist text: {}
    PRIMARY KEY (first_letter {}, artist {})
CREATE TABLE playlist.track_by_id:
    track_id uuid PRIMARY KEY: {}
    artist text: {}
    genre text: {}
    music_file text: {}
    track text: {}
    track_length_in_seconds int: {}
NEO4J CREDENTIALS (url {}, user {}, password {}) 
```    

**Every table will be translated as a Node in Neo4j.**

Note the __{}__. It's possible to fill them up with the following options:

* _p_, for regular node property (fill with __{p}__),
* __r__ for relationship (fill with __{r}__),
* __u__ for unique constraint field (fill with __{u}__) 

For example:

```
CREATE TABLE playlist.artists_by_first_letter:
    first_letter text: {p}
    artist text: {r}
    PRIMARY KEY (first_letter {p}, artist {u})
CREATE TABLE playlist.track_by_id:
    track_id uuid PRIMARY KEY: {u}
    artist text: {r}
    genre text: {p}
    music_file text: {p}
    track text: {p}
    track_length_in_seconds int: {p}
```

An example of filled YAML file can be found on __connector/schema.yaml.example__.

===== Important points to consider when mapping:

For this first version, we still do not have a strong error handling. So please be aware of the following aspects:

* If you fill up a field as a relationship willing to have a relationship between two nodes, please map the field with __r__ in both table. In the example above, note that __artist__ is mapped as __r__ in both tables, __playlist.track_by_artist__ and __playlist.track_by_id__.


* After filling up the empty brackets, save the file and run the script ::connector.py::, now specifying the __filled__ option:
```
python connector.py filled
```
*The YAML file will be parsed into Cypher queries. A file called **cypher_** will be generated in your directory. It contains the Cypher queries that can be passed to Neo4j.

You should end up seeing several ::artist:: and ::track:: nodes and several relationships between them:

image::resources/images/intro.png[Initial Import to Neo4j]
